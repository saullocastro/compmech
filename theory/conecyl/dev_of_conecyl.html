<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Developing the code for the conecyl module &mdash; CompMech 0.7.1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.png"/>
    <link rel="author" title="About these documents" href="../../about.html" />
    <link rel="top" title="CompMech 0.7.1 documentation" href="../../index.html" />
    <link rel="up" title="Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)" href="index.html" />
    <link rel="next" title="Equivalent Single Layer (ESL) Theories" href="esl_theories.html" />
    <link rel="prev" title="Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)" href="index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="esl_theories.html" title="Equivalent Single Layer (ESL) Theories"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CompMech 0.7.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Theory, Implementation and Tutorials</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="developing-the-code-for-the-conecyl-module">
<h1>Developing the code for the conecyl module<a class="headerlink" href="#developing-the-code-for-the-conecyl-module" title="Permalink to this headline">¶</a></h1>
<div class="section" id="history-about-the-software-used-to-derive-the-equations">
<h2>History about the software used to derive the equations<a class="headerlink" href="#history-about-the-software-used-to-derive-the-equations" title="Permalink to this headline">¶</a></h2>
<p>The equations are symbolically evaluated using a matrix notation, as explained
in FIXME ADD REFERENCES.
Initially the project used SymPy to derive the integrands and to perform the
analytical integrations. Since SymPy showed to be very slow for the integrands
herein evaluated, SymPy was used to derive the integrands and Mathematica used
to perform the integrations. This required a considerable effort on data
management and therefore it was decided to move the derivation of the
integrands inside Mathematica. Now in Mathematica it is derived all the
integrands, the analytical integration calculated and the symbolic
simplifications performed, which is also an important and computationally
expensive step.</p>
<p>SymPy is used to post process the results from Mathematica and print the
matrices in a ready-to-paste-into-Cython form.</p>
</div>
<div class="section" id="current-implementations">
<h2>Current implementations<a class="headerlink" href="#current-implementations" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>static analysis (linear or non-linear)</li>
<li>buckling analysis (linear or non-linear, using initial imperfections)</li>
<li>load conditions: axial compression, torsion, pressure and any set of
surface loads, concentraded or not</li>
</ul>
</div>
<div class="section" id="definitions">
<h2>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h2>
<p>In the <a class="reference internal" href="esl_theories.html#esl-theories"><span class="std std-ref">ESL theories section</span></a> it is explained
the types of kinematic equation implemented, defining the <code class="docutils literal"><span class="pre">ESL</span> <span class="pre">theory</span></code>
prefix mentioned below (currently <code class="docutils literal"><span class="pre">clpt</span></code> or <code class="docutils literal"><span class="pre">fsdt</span></code>).</p>
<p>The <code class="docutils literal"><span class="pre">equation</span> <span class="pre">type</span></code> prefix will be <code class="docutils literal"><span class="pre">donnell</span></code> or <code class="docutils literal"><span class="pre">sanders</span></code>, defining
if the model is built using the Donnell&#8217;s or the Sanders&#8217; non-linear
equations.</p>
</div>
<div class="section" id="integration-of-the-linear-matrices">
<h2>Integration of the linear matrices<a class="headerlink" href="#integration-of-the-linear-matrices" title="Permalink to this headline">¶</a></h2>
<p>The linear matrices K0 and KG0 are integrated analytically, and the
Mathematica routines necessary for this task are named as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">ESL</span> <span class="n">theory</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">equation</span> <span class="nb">type</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">boundary</span> <span class="n">condition</span><span class="p">}</span><span class="n">_linear</span><span class="o">.</span><span class="n">nb</span>
</pre></div>
</div>
<p>Each integrated smallest repeatable sub-matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">00</span><span class="p">,</span> <span class="mi">01</span><span class="p">,</span> <span class="mi">02</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span> <span class="ow">and</span> <span class="mi">22</span>
</pre></div>
</div>
<p>are stored in two text files inside the folder <code class="docutils literal"><span class="pre">./linear_mathematica</span></code>,
one with a Mathematica format and another in Fortran format,
identified with a prefix
<code class="docutils literal"><span class="pre">fortran_</span></code>. Since the integrated matrices are greatly simplified for the
cylinder case, there are files for both cones and cylinders.</p>
<p>The routine <code class="docutils literal"><span class="pre">print_linear_sparse.py</span></code> is used to convert the Fortran
format to a
ready-to-past-in-Cython format, separating in <code class="docutils literal"><span class="pre">row</span></code>, <code class="docutils literal"><span class="pre">col</span></code> and <code class="docutils literal"><span class="pre">value</span></code>,
which is convenient for the implementation using sparse matrices. The
generated files are stored in <code class="docutils literal"><span class="pre">./linear_sparse</span></code>. Note that the power
functions <code class="docutils literal"><span class="pre">var**3</span></code> are transformed in <code class="docutils literal"><span class="pre">(var*var*var)</span></code>, by default,
which can be modified by changing the parameters in the
<code class="docutils literal"><span class="pre">mprint_as_sparse()</span></code> function.</p>
<p>The integrated sparse matrices are pasted in the corresponding Cython codes,
currently:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">clpt_donnell_bcX_linear</span><span class="o">.</span><span class="n">pyx</span>
<span class="n">clpt_sanders_bcX_linear</span><span class="o">.</span><span class="n">pyx</span>
<span class="n">fsdt_donnell_bcX_linear</span><span class="o">.</span><span class="n">pyx</span>
</pre></div>
</div>
</div>
<div class="section" id="integration-of-the-non-linear-matrices">
<h2>Integration of the non-linear matrices<a class="headerlink" href="#integration-of-the-non-linear-matrices" title="Permalink to this headline">¶</a></h2>
<p>The non-linear matrices <code class="docutils literal"><span class="pre">K0L</span></code>, <code class="docutils literal"><span class="pre">KG</span></code> and <code class="docutils literal"><span class="pre">KLL</span></code> are not integrated
analytically and their integrands are built for the numerical integration
algorithms. Mathematica is used to build the integrands, in the routines
named as:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">ESL</span> <span class="n">theory</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">equation</span> <span class="nb">type</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">boundary</span> <span class="n">condition</span><span class="p">}</span><span class="n">_nonlinear</span><span class="o">.</span><span class="n">nb</span>
</pre></div>
</div>
<p>The output is printed inside <code class="docutils literal"><span class="pre">./nonlinear_mathematica</span></code> and the routine
<code class="docutils literal"><span class="pre">print_nonlinear_sparse.py</span></code> is used to parse these results into something
that can be directly implemented into Cython, and the new outputs are
stored in <code class="docutils literal"><span class="pre">./nonlinear_sparse</span></code>.</p>
<p>For each sub-matrix:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="mi">00</span><span class="p">,</span> <span class="mi">01</span><span class="p">,</span> <span class="mi">02</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span>
</pre></div>
</div>
<p>there will be a corresponding file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_</span><span class="p">{</span><span class="n">cone</span> <span class="ow">or</span> <span class="n">cylinder</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">matrix</span> <span class="n">name</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">sub</span><span class="o">-</span><span class="n">matrix</span><span class="p">}</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>The sub-matrix is identified by a left and a right digit (<code class="docutils literal"><span class="pre">0</span></code>, <code class="docutils literal"><span class="pre">1</span></code> or
<code class="docutils literal"><span class="pre">2</span></code>) that indicate the region of the stiffness matrix that this
sub-matrix refers to.</p>
<p>The sub-matrices&#8217; integrands are printed in a format ready to be programmed
using sparse matrices:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">rows</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">+</span><span class="mi">4</span>
<span class="n">out</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">beta</span><span class="o">*</span><span class="n">out</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">+</span> <span class="n">alpha</span><span class="o">*</span><span class="p">(</span><span class="n">p00</span><span class="o">*</span><span class="n">q04</span> <span class="o">+</span> <span class="n">p01</span><span class="o">*</span><span class="n">q14</span> <span class="o">+</span> <span class="n">p02</span><span class="o">*</span><span class="n">q24</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal"><span class="pre">alpha</span></code> and <code class="docutils literal"><span class="pre">beta</span></code> are arguments passed by the numerical integration
algorithm (they give a pre-calculated weight for the point being integrated),
<code class="docutils literal"><span class="pre">pij</span></code> are the left <code class="docutils literal"><span class="pre">qij</span></code> the right components of the integrand.</p>
<p>The definitions of <code class="docutils literal"><span class="pre">pij</span></code> and <code class="docutils literal"><span class="pre">qij</span></code> are given in the corresponding files
with a <code class="docutils literal"><span class="pre">p</span></code> and a <code class="docutils literal"><span class="pre">q</span></code> character after the matrix name:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_</span><span class="p">{</span><span class="n">cone</span> <span class="ow">or</span> <span class="n">cylinder</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">matrix</span> <span class="n">name</span><span class="p">}</span><span class="n">p_</span><span class="p">{</span><span class="n">left</span> <span class="n">digit</span><span class="p">}</span><span class="o">.</span><span class="n">txt</span>
<span class="n">fortran_</span><span class="p">{</span><span class="n">cone</span> <span class="ow">or</span> <span class="n">cylinder</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">matrix</span> <span class="n">name</span><span class="p">}</span><span class="n">q_</span><span class="p">{</span><span class="n">right</span> <span class="n">digit</span><span class="p">}</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>For example, to calculate the smallest repeatable sub-matrix <code class="docutils literal"><span class="pre">12</span></code> of
<code class="docutils literal"><span class="pre">KG</span></code>, first the file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_cone_kG_12</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>should be openened, and the definitions for <code class="docutils literal"><span class="pre">pij</span></code> are found in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_cone_kGNLp_1</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>and the definitions for <code class="docutils literal"><span class="pre">qij</span></code> are found in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_cone_kGNLq_2</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>These are implemented in:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">clpt_donnell_bcX_nonlinear</span><span class="o">.</span><span class="n">pyx</span>
<span class="n">clpt_sanders_bcX_nonlinear</span><span class="o">.</span><span class="n">pyx</span>
<span class="n">fsdt_donnell_bcX_nonlinear</span><span class="o">.</span><span class="n">pyx</span>
</pre></div>
</div>
</div>
<div class="section" id="strain-equations">
<h2>Strain Equations<a class="headerlink" href="#strain-equations" title="Permalink to this headline">¶</a></h2>
<p>When the non-linear integrands are built another file containing the
strain equations is written:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_strainFunc</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>This file is processed using the routine:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">print_strainFunc</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>which creates the output files:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">output_strainFunc</span><span class="o">.</span><span class="n">txt</span>
<span class="n">output_e0</span><span class="o">.</span><span class="n">txt</span>
<span class="n">output_eL</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>the first with the full strain relations, the second with the linear
and the third with the non-linear strain relations. The format saved
is easy to implement in the Cython codes:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">clpt_commons_bcX</span><span class="o">.</span><span class="n">pyx</span>
<span class="n">fsdt_commons_bcX</span><span class="o">.</span><span class="n">pyx</span>
</pre></div>
</div>
</div>
<div class="section" id="internal-forces">
<h2>Internal Forces<a class="headerlink" href="#internal-forces" title="Permalink to this headline">¶</a></h2>
<p>The internal force vector <img class="math" src="../../_images/math/60e3b47a4eb49c8c930c30b9bf80d5cb987f35c9.png" alt="\{F_{int}\}"/> is separated in four parts:</p>
<div class="math">
<p><img src="../../_images/math/b34f74aaf3638a980c0b9819459af6d8f555c2e8.png" alt="\{F_{int}\} = \{F_{int}\}_{00} + \{F_{int}\}_{0L} +
              \{F_{int}\}_{L0} + \{F_{int}\}_{LL}"/></p>
</div><p>As can be seen in function <a class="reference internal" href="../../modules/conecyl/index.html#compmech.conecyl.ConeCyl.calc_fint" title="compmech.conecyl.ConeCyl.calc_fint"><code class="xref py py-meth docutils literal"><span class="pre">compmech.conecyl.ConeCyl.calc_fint()</span></code></a>,
the linear component <img class="math" src="../../_images/math/72cc35d5e606f688c08945806109882e3e8d948b.png" alt="\{F_{int}\}_{00}"/> is calculated using:</p>
<div class="math">
<p><img src="../../_images/math/798fedcfc2cf5c6b87082c8840363c8f10de1bd9.png" alt="\{F_{int}\}_{00} = [K_0]\{c\}"/></p>
</div><p>because <img class="math" src="../../_images/math/ca28b2833c10991ea042899048cb950e3b10a235.png" alt="[K_0]"/> is calculated analytically and the numerical integration
errors are avoided in this way. For the other three terms <img class="math" src="../../_images/math/d3fa4303d2d74cef548cb767ad5b2807a322f6a5.png" alt="0L"/>, <img class="math" src="../../_images/math/11fbcada63a169dd423d9f473d56fc0e0ca61ac3.png" alt="L0"/> and
<img class="math" src="../../_images/math/48adb3ef59398490da97df22e078758e96813935.png" alt="LL"/>, a numerical integration is performed. It is important
to say that computational cost associated
with the numerical integration of <img class="math" src="../../_images/math/60e3b47a4eb49c8c930c30b9bf80d5cb987f35c9.png" alt="\{F_{int}\}"/> is approximately
<img class="math" src="../../_images/math/fe02a797055ce3bc794a574b37da80b191be5b59.png" alt="m_2 \times n_2"/> smaller than the integraion of <img class="math" src="../../_images/math/6de489b578ca938805144e2400be7e2773da19ab.png" alt="[K_T]"/>.</p>
<p>The Mathematica routine:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">ESL</span> <span class="n">theory</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">equation</span> <span class="nb">type</span><span class="p">}</span><span class="n">_</span><span class="p">{</span><span class="n">boundary</span> <span class="n">condition</span><span class="p">}</span><span class="n">_nonlinear</span><span class="o">.</span><span class="n">nb</span>
</pre></div>
</div>
<p>produces a file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">fortran_fint_L0_0L_LL</span><span class="o">.</span><span class="n">txt</span>
</pre></div>
</div>
<p>which is post-processed by the routine:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">print_fint_L0_0L_LL</span><span class="o">.</span><span class="n">py</span>
</pre></div>
</div>
<p>that prints into <code class="docutils literal"><span class="pre">./nonlinear_sparse</span></code> in a ready-to-paste format, that
is copy-pasted in Cython.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../../index.html">
              <img class="logo" src="../../_static/logo.png" alt="Logo"/>
            </a></p>
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Developing the code for the conecyl module</a><ul>
<li><a class="reference internal" href="#history-about-the-software-used-to-derive-the-equations">History about the software used to derive the equations</a></li>
<li><a class="reference internal" href="#current-implementations">Current implementations</a></li>
<li><a class="reference internal" href="#definitions">Definitions</a></li>
<li><a class="reference internal" href="#integration-of-the-linear-matrices">Integration of the linear matrices</a></li>
<li><a class="reference internal" href="#integration-of-the-non-linear-matrices">Integration of the non-linear matrices</a></li>
<li><a class="reference internal" href="#strain-equations">Strain Equations</a></li>
<li><a class="reference internal" href="#internal-forces">Internal Forces</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="index.html"
                        title="previous chapter">Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="esl_theories.html"
                        title="next chapter">Equivalent Single Layer (ESL) Theories</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/theory/conecyl/dev_of_conecyl.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="esl_theories.html" title="Equivalent Single Layer (ESL) Theories"
             >next</a> |</li>
        <li class="right" >
          <a href="index.html" title="Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">CompMech 0.7.1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Theory, Implementation and Tutorials</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >Semi-Analytical Models for Conical and Cylindrical Shells (conecyl)</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2016 Saullo G. P. Castro.
      Last updated on Oct 08, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.3.
    </div>
  </body>
</html>